// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.5.2 (swiftlang-1300.0.47.5 clang-1300.0.29.30)
// swift-module-flags: -target x86_64-apple-ios13.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -Onone -module-name SmartVideo
import AVFoundation
import AVKit
import CallKit
import CommonCrypto
import CoreAudioTypes
import Foundation
import Network
import PDFKit
import Photos
import ReplayKit
@_exported import SmartVideo
import Swift
import SystemConfiguration
import UIKit
import WebRTC
import _Concurrency
import zlib
@frozen public struct AnyDecodable : Swift.Decodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyDecodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension SmartVideo.AnyDecodable : SmartVideo._AnyDecodable {
}
extension SmartVideo._AnyDecodable {
  public init(from decoder: Swift.Decoder) throws
}
extension SmartVideo.AnyDecodable : Swift.Equatable {
  public static func == (lhs: SmartVideo.AnyDecodable, rhs: SmartVideo.AnyDecodable) -> Swift.Bool
}
extension SmartVideo.AnyDecodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SmartVideo.AnyDecodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
public enum FoundationSecurityError : Swift.Error {
  case invalidRequest
  public static func == (a: SmartVideo.FoundationSecurityError, b: SmartVideo.FoundationSecurityError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public class FoundationSecurity {
  public init(allowSelfSigned: Swift.Bool = false)
  @objc deinit
}
extension SmartVideo.FoundationSecurity : SmartVideo.CertificatePinning {
  public func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((SmartVideo.PinningState) -> ()))
}
extension SmartVideo.FoundationSecurity : SmartVideo.HeaderValidator {
  public func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> Swift.Error?
}
public protocol SmartVideoEngine {
  func connect()
  func disconnect()
  func applicationDidBecomeActive()
}
public enum TCPTransportError : Swift.Error {
  case invalidRequest
  public static func == (a: SmartVideo.TCPTransportError, b: SmartVideo.TCPTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class TCPTransport : SmartVideo.Transport {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(connection: Network.NWConnection)
  public init()
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: SmartVideo.CertificatePinning? = nil)
  public func disconnect()
  public func register(delegate: SmartVideo.TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> ()))
  @objc deinit
}
@objc public class File : ObjectiveC.NSObject {
  public init(id: Swift.String, _ fileInfo: SmartVideo.FileInfo)
  @objc deinit
}
public enum FileStatus {
  case waiting
  case transferring
  case rejected
  case done
  public static func == (a: SmartVideo.FileStatus, b: SmartVideo.FileStatus) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct Version : Swift.Comparable {
  public let major: Swift.Int
  public let minor: Swift.Int
  public let patch: Swift.Int
  public let prereleaseIdentifiers: [Swift.String]
  public let buildMetadataIdentifiers: [Swift.String]
  public init(_ major: Swift.Int, _ minor: Swift.Int, _ patch: Swift.Int, prereleaseIdentifiers: [Swift.String] = [], buildMetadataIdentifiers: [Swift.String] = [])
  public static func < (lhs: SmartVideo.Version, rhs: SmartVideo.Version) -> Swift.Bool
  public static func == (a: SmartVideo.Version, b: SmartVideo.Version) -> Swift.Bool
}
extension SmartVideo.Version : Swift.ExpressibleByStringLiteral {
  public init(stringLiteral value: Swift.String)
  public init(_ version: SmartVideo.Version)
  public init?(_ versionString: Swift.String)
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension SmartVideo.Version : Swift.CustomStringConvertible {
  public enum Format {
    case full
    case compact
    public static func == (a: SmartVideo.Version.Format, b: SmartVideo.Version.Format) -> Swift.Bool
    public func hash(into hasher: inout Swift.Hasher)
    public var hashValue: Swift.Int {
      get
    }
  }
  public func formatted(_ format: SmartVideo.Version.Format) -> Swift.String
  public var description: Swift.String {
    get
  }
}
extension SmartVideo.Version : Swift.Codable {
  public init(from decoder: Swift.Decoder) throws
  public func encode(to encoder: Swift.Encoder) throws
}
public struct GenesysEngageConfigurations {
  public let environment: SmartVideo.Environment
  public let engineURL: Swift.String
  public let chatURL: Swift.String
  public var serverBaseURL: Swift.String
  public var service: Swift.String
  public var agentURL: Swift.String
  public var authorizationValue: Swift.String
  public init(environment: SmartVideo.Environment, engineURL: Swift.String, chatURL: Swift.String, serverBaseURL: Swift.String, service: Swift.String, agentURL: Swift.String, authorizationValue: Swift.String)
  public init(dictionary: [Swift.String : Any]) throws
}
@frozen public struct AnyEncodable : Swift.Encodable {
  public let value: Any
  public init<T>(_ value: T?)
}
@usableFromInline
internal protocol _AnyEncodable {
  var value: Any { get }
  init<T>(_ value: T?)
}
extension SmartVideo.AnyEncodable : SmartVideo._AnyEncodable {
}
extension SmartVideo._AnyEncodable {
  public func encode(to encoder: Swift.Encoder) throws
}
extension SmartVideo.AnyEncodable : Swift.Equatable {
  public static func == (lhs: SmartVideo.AnyEncodable, rhs: SmartVideo.AnyEncodable) -> Swift.Bool
}
extension SmartVideo.AnyEncodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SmartVideo.AnyEncodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SmartVideo.AnyEncodable : Swift.ExpressibleByNilLiteral {
}
extension SmartVideo.AnyEncodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension SmartVideo.AnyEncodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension SmartVideo.AnyEncodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension SmartVideo.AnyEncodable : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension SmartVideo.AnyEncodable : Swift.ExpressibleByStringInterpolation {
  public typealias StringInterpolation = Swift.DefaultStringInterpolation
}
extension SmartVideo.AnyEncodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension SmartVideo.AnyEncodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
extension SmartVideo._AnyEncodable {
  public init(nilLiteral _: ())
  public init(booleanLiteral value: Swift.Bool)
  public init(integerLiteral value: Swift.Int)
  public init(floatLiteral value: Swift.Double)
  public init(extendedGraphemeClusterLiteral value: Swift.String)
  public init(stringLiteral value: Swift.String)
  public init(arrayLiteral elements: Any...)
  public init(dictionaryLiteral elements: (Swift.AnyHashable, Any)...)
}
public protocol FrameCollectorDelegate : AnyObject {
  func didForm(event: SmartVideo.FrameCollector.Event)
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
}
@_hasMissingDesignatedInitializers public class FrameCollector {
  public enum Event {
    case text(Swift.String)
    case binary(Foundation.Data)
    case pong(Foundation.Data?)
    case ping(Foundation.Data?)
    case error(Swift.Error)
    case closed(Swift.String, Swift.UInt16)
  }
  public func add(frame: SmartVideo.Frame)
  @objc deinit
}
public enum HTTPUpgradeError : Swift.Error {
  case notAnUpgrade(Swift.Int, [Swift.String : Swift.String])
  case invalidData
}
public struct HTTPWSHeader {
  public static func createUpgrade(request: Foundation.URLRequest, supportsCompression: Swift.Bool, secKeyValue: Swift.String) -> Foundation.URLRequest
  public static func generateWebSocketKey() -> Swift.String
}
public enum HTTPEvent {
  case success([Swift.String : Swift.String])
  case failure(Swift.Error)
}
public protocol HTTPHandlerDelegate : AnyObject {
  func didReceiveHTTP(event: SmartVideo.HTTPEvent)
}
public protocol HTTPHandler {
  func register(delegate: SmartVideo.HTTPHandlerDelegate)
  func convert(request: Foundation.URLRequest) -> Foundation.Data
  func parse(data: Foundation.Data) -> Swift.Int
}
public protocol HTTPServerDelegate : AnyObject {
  func didReceive(event: SmartVideo.HTTPEvent)
}
public protocol HTTPServerHandler {
  func register(delegate: SmartVideo.HTTPServerDelegate)
  func parse(data: Foundation.Data)
  func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
}
public struct URLParts {
}
extension Foundation.URL {
  public var isTLSScheme: Swift.Bool {
    get
  }
  public func getParts() -> SmartVideo.URLParts?
}
public class WSEngine : SmartVideo.Engine, SmartVideo.TransportEventClient, SmartVideo.FramerEventClient, SmartVideo.FrameCollectorDelegate, SmartVideo.HTTPHandlerDelegate {
  public var respondToPingWithPong: Swift.Bool
  public init(transport: SmartVideo.Transport, certPinner: SmartVideo.CertificatePinning? = nil, headerValidator: SmartVideo.HeaderValidator = FoundationSecurity(), httpHandler: SmartVideo.HTTPHandler = FoundationHTTPHandler(), framer: SmartVideo.Framer = WSFramer(), compressionHandler: SmartVideo.CompressionHandler? = nil)
  public func register(delegate: SmartVideo.EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceStop()
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(data: Foundation.Data, opcode: SmartVideo.FrameOpCode, completion: (() -> ())?)
  public func connectionChanged(state: SmartVideo.ConnectionState)
  public func didReceiveHTTP(event: SmartVideo.HTTPEvent)
  public func frameProcessed(event: SmartVideo.FrameEvent)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func didForm(event: SmartVideo.FrameCollector.Event)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @available(macOS 10.15, iOS 13.0, watchOS 6.0, tvOS 13.0, *)
public class NativeEngine : ObjectiveC.NSObject, SmartVideo.Engine, Foundation.URLSessionDataDelegate, Foundation.URLSessionWebSocketDelegate {
  public func register(delegate: SmartVideo.EngineDelegate)
  public func start(request: Foundation.URLRequest)
  public func stop(closeCode: Swift.UInt16)
  public func forceStop()
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(data: Foundation.Data, opcode: SmartVideo.FrameOpCode, completion: (() -> ())?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didOpenWithProtocol protocol: Swift.String?)
  @objc public func urlSession(_ session: Foundation.URLSession, webSocketTask: Foundation.URLSessionWebSocketTask, didCloseWith closeCode: Foundation.URLSessionWebSocketTask.CloseCode, reason: Foundation.Data?)
  @objc override dynamic public init()
  @objc deinit
}
@frozen public struct AnyCodable : Swift.Codable {
  public let value: Any
  public init<T>(_ value: T?)
}
extension SmartVideo.AnyCodable : SmartVideo._AnyEncodable, SmartVideo._AnyDecodable {
}
extension SmartVideo.AnyCodable : Swift.Equatable {
  public static func == (lhs: SmartVideo.AnyCodable, rhs: SmartVideo.AnyCodable) -> Swift.Bool
}
extension SmartVideo.AnyCodable : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
extension SmartVideo.AnyCodable : Swift.CustomDebugStringConvertible {
  public var debugDescription: Swift.String {
    get
  }
}
extension SmartVideo.AnyCodable : Swift.ExpressibleByNilLiteral {
}
extension SmartVideo.AnyCodable : Swift.ExpressibleByBooleanLiteral {
  public typealias BooleanLiteralType = Swift.Bool
}
extension SmartVideo.AnyCodable : Swift.ExpressibleByIntegerLiteral {
  public typealias IntegerLiteralType = Swift.Int
}
extension SmartVideo.AnyCodable : Swift.ExpressibleByFloatLiteral {
  public typealias FloatLiteralType = Swift.Double
}
extension SmartVideo.AnyCodable : Swift.ExpressibleByStringLiteral {
  public typealias ExtendedGraphemeClusterLiteralType = Swift.String
  public typealias StringLiteralType = Swift.String
  public typealias UnicodeScalarLiteralType = Swift.String
}
extension SmartVideo.AnyCodable : Swift.ExpressibleByArrayLiteral {
  public typealias ArrayLiteralElement = Any
}
extension SmartVideo.AnyCodable : Swift.ExpressibleByDictionaryLiteral {
  public typealias Key = Swift.AnyHashable
  public typealias Value = Any
}
public enum FoundationTransportError : Swift.Error {
  case invalidRequest
  case invalidOutputStream
  case timeout
  public static func == (a: SmartVideo.FoundationTransportError, b: SmartVideo.FoundationTransportError) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
@objc public class FoundationTransport : ObjectiveC.NSObject, SmartVideo.Transport, Foundation.StreamDelegate {
  public var usingTLS: Swift.Bool {
    get
  }
  public init(streamConfiguration: ((Foundation.InputStream, Foundation.OutputStream) -> Swift.Void)? = nil)
  @objc deinit
  public func connect(url: Foundation.URL, timeout: Swift.Double = 10, certificatePinning: SmartVideo.CertificatePinning? = nil)
  public func disconnect()
  public func register(delegate: SmartVideo.TransportEventClient)
  public func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> ()))
  @objc open func stream(_ aStream: Foundation.Stream, handle eventCode: Foundation.Stream.Event)
}
public struct UserAgent : Swift.Codable, Swift.Equatable {
  public static var shared: SmartVideo.UserAgent
  public static func == (a: SmartVideo.UserAgent, b: SmartVideo.UserAgent) -> Swift.Bool
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
extension SmartVideo.UserAgent : Swift.CustomStringConvertible {
  public var description: Swift.String {
    get
  }
}
@_hasMissingDesignatedInitializers public class GenesysEngage {
  public static var shared: SmartVideo.GenesysEngage
  public func connect(with connectEngine: SmartVideo.GenesysEngageEngine)
  public func updateConfiguration(configuration: SmartVideo.GenesysEngageConfigurations)
  @objc deinit
}
public struct FileInfo : Swift.Codable {
  public var name: Swift.String
  public var type: Swift.String
  public var size: Swift.Int
  public func encode(to encoder: Swift.Encoder) throws
  public init(from decoder: Swift.Decoder) throws
}
public protocol CompressionHandler {
  func load(headers: [Swift.String : Swift.String])
  func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  func compress(data: Foundation.Data) -> Foundation.Data?
}
public protocol WebRTCManagerDelegate : AnyObject {
  func remoteVideoChanged(state: SmartVideo.VideoStreamState)
  func remoteAudioChanged(state: SmartVideo.AudioStreamState)
  func localVideoChanged(state: SmartVideo.VideoStreamState)
  func localAudioChanged(state: SmartVideo.AudioStreamState)
  func remoteScreenChanged(state: SmartVideo.VideoStreamState)
  func torchControl(isSupported: Swift.Bool)
  func torchConfigError()
  func cameraStateChanged(processing: Swift.Bool)
  func peerConnectionLost()
  func peerConnectionEstablished()
}
@_hasMissingDesignatedInitializers public class Genesys {
  public static var shared: SmartVideo.Genesys
  public func connect(with connectEngine: SmartVideo.GenesysEngine)
  public func disconnect()
  public func applicationDidBecomeActive()
  public func updateConfiguration(configuration: SmartVideo.GenesysConfigurations)
  @objc deinit
}
extension SmartVideo.Genesys : SmartVideo.WebSocketDelegate {
  public func didReceive(event: SmartVideo.WebSocketEvent, client: SmartVideo.WebSocketClient)
}
extension SmartVideo.SmartVideo {
  public static func sendGenesysCloudChat(message: SmartVideo.ChatMessage)
}
public class FoundationHTTPHandler : SmartVideo.HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: SmartVideo.HTTPHandlerDelegate)
  @objc deinit
}
@objc @_inheritsConvenienceInitializers @_Concurrency.MainActor(unsafe) public class OutgoingCallVC : UIKit.UIViewController {
  @_Concurrency.MainActor(unsafe) public var hasVideo: Swift.Bool
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override dynamic public func viewWillAppear(_ animated: Swift.Bool)
  @objc deinit
  @_Concurrency.MainActor(unsafe) @objc override dynamic public var preferredStatusBarStyle: UIKit.UIStatusBarStyle {
    @_Concurrency.MainActor(unsafe) @objc get
  }
  @_Concurrency.MainActor(unsafe) @objc override dynamic public init(nibName nibNameOrNil: Swift.String?, bundle nibBundleOrNil: Foundation.Bundle?)
  @_Concurrency.MainActor(unsafe) @objc required dynamic public init?(coder: Foundation.NSCoder)
}
@objc public class ChatMessage : ObjectiveC.NSObject {
  final public let message: Swift.String
  final public let date: Foundation.Date
  final public let sender: Swift.String?
  public init(message: Swift.String, date: Foundation.Date, sender: Swift.String? = nil)
  @objc deinit
}
public struct GenesysConfigurations {
  public let environment: SmartVideo.Environment
  public var organizationID: Swift.String
  public var deploymentID: Swift.String
  public var engineUrl: Swift.String
  public var environmentURL: Swift.String
  public var queue: Swift.String
  public var baseURL: Swift.String
  public init(environment: SmartVideo.Environment, organizationID: Swift.String, deploymentID: Swift.String, shortUrl: Swift.String, tenantId: Swift.String, environmentURL: Swift.String, queue: Swift.String, engineUrl: Swift.String)
  public init(dictionary: [Swift.String : Any]) throws
}
public class WSCompression : SmartVideo.CompressionHandler {
  public init()
  public func load(headers: [Swift.String : Swift.String])
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  public func compress(data: Foundation.Data) -> Foundation.Data?
  @objc deinit
}
public enum CloseCode : Swift.UInt16 {
  case normal
  case goingAway
  case protocolError
  case protocolUnhandledType
  case noStatusReceived
  case encoding
  case policyViolated
  case messageTooBig
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum FrameOpCode : Swift.UInt8 {
  case continueFrame
  case textFrame
  case binaryFrame
  case connectionClose
  case ping
  case pong
  case unknown
  public init?(rawValue: Swift.UInt8)
  public typealias RawValue = Swift.UInt8
  public var rawValue: Swift.UInt8 {
    get
  }
}
public struct Frame {
}
public enum FrameEvent {
  case frame(SmartVideo.Frame)
  case error(Swift.Error)
}
public protocol FramerEventClient : AnyObject {
  func frameProcessed(event: SmartVideo.FrameEvent)
}
public protocol Framer {
  func add(data: Foundation.Data)
  func register(delegate: SmartVideo.FramerEventClient)
  func createWriteFrame(opcode: SmartVideo.FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  func updateCompression(supports: Swift.Bool)
  func supportsCompression() -> Swift.Bool
}
public class WSFramer : SmartVideo.Framer {
  public var compressionEnabled: Swift.Bool
  public init(isServer: Swift.Bool = false)
  public func updateCompression(supports: Swift.Bool)
  public func supportsCompression() -> Swift.Bool
  public func add(data: Foundation.Data)
  public func register(delegate: SmartVideo.FramerEventClient)
  public func createWriteFrame(opcode: SmartVideo.FrameOpCode, payload: Foundation.Data, isCompressed: Swift.Bool) -> Foundation.Data
  @objc deinit
}
public protocol MyWSArrayType {
}
extension Swift.UInt8 : SmartVideo.MyWSArrayType {
}
extension Swift.Array where Element : SmartVideo.MyWSArrayType, Element : Swift.UnsignedInteger {
  public func readUint16(offset: Swift.Int) -> Swift.UInt16
  public func readUint64(offset: Swift.Int) -> Swift.UInt64
  public func unmaskData(maskStart: Swift.Int, offset: Swift.Int, length: Swift.Int) -> Foundation.Data
}
public func writeUint16(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt16)
public func writeUint32(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt32)
public func writeUint64(_ buffer: inout [Swift.UInt8], offset: Swift.Int, value: Swift.UInt64)
@_hasMissingDesignatedInitializers open class SmartVideo {
  public static var version: Swift.String
  public static var environment: SmartVideo.Environment
  public static var delegate: SmartVideo.SmartVideoDelegate?
  public static var chatDelegate: SmartVideo.SmartVideoChatDelegate?
  public static var callManager: SmartVideo.CallManager
  public static func connect(shortURL: Swift.String)
  public static func connect(engine: SmartVideo.SmartVideoEngine, isVideo: Swift.Bool? = nil, lang: Swift.String)
  public static func disconnect()
  public static func setLogging(level: SmartVideo.LogLevel, types: [SmartVideo.LogType])
  public static func applicationDidBecomeActive()
  @objc deinit
}
@objc public protocol SmartVideoDelegate {
  @objc func didEstablishCommunicationChannel(type: SmartVideo.SmartVideoCommunicationChannelType)
  @objc func callStatusChanged(status: SmartVideo.SmartVideoCallStatus)
  @objc optional func genesysCloudChat(message: Swift.String)
  @objc optional func genesysCloudChat(data: Foundation.Data)
  @objc optional func genesysCloudChat(status: Swift.String)
  @objc optional func genesysEngageChat(message: Swift.String, from: Swift.String)
  @objc optional func isConnectedToInternet(isConnected: Swift.Bool)
  @objc optional func errorHandler(error: SmartVideo.SmartVideoError)
  @objc optional func peerConnectionLost()
}
@objc public protocol SmartVideoChatDelegate {
  @objc optional func genesysCloudChat(message: SmartVideo.ChatMessage)
  @objc optional func chatStatusChanged(status: SmartVideo.SmartVideoChatStatus)
  @objc optional func errorHandler(error: SmartVideo.SmartVideoError)
  @objc optional func endChat()
}
@_hasMissingDesignatedInitializers @objc public class GenesysAgentInfo : ObjectiveC.NSObject {
  public var id: Swift.String
  public var displayName: Swift.String?
  public var avatarImageUrl: Swift.String?
  @objc deinit
}
@objc public enum SmartVideoChatStatus : Swift.Int {
  case interactionStarted
  case interactionEstablished
  case agentAnswered
  case chatFinished
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum SmartVideoCallStatus : Swift.Int {
  case interactionStarted
  case interactionEstablished
  case callWaiting
  case callStarted
  case callOnHold
  case callFinished
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum SmartVideoCommunicationChannelType : Swift.Int {
  case call
  case chat
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum Environment : Swift.String {
  case staging
  case live
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
@objc public enum VideoStreamState : Swift.Int {
  case loading
  case ready
  case playing
  case stopped
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum AudioStreamState : Swift.Int {
  case loading
  case ready
  case muted
  case unmuted
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum OngoingCallState : Swift.Int {
  case agentPutsCallOnHold
  case agentResumesCallOnHold
  case visitorPutsCallOnHold
  case visitorResumesCallOnHold
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@objc public enum FileTransferState : Swift.Int {
  case inactive
  case inprogress
  case done
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
@_hasMissingDesignatedInitializers @objc public class SmartVideoError : ObjectiveC.NSObject {
  public var type: SmartVideo.SmartVideoErrorType
  public var error: Swift.String
  @objc deinit
}
@objc public enum SmartVideoErrorType : Swift.Int {
  case rest
  case socket
  case webRTC
  case genesysSocket
  case sdkInitialization
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public class StringHTTPHandler : SmartVideo.HTTPHandler {
  public init()
  public func convert(request: Foundation.URLRequest) -> Foundation.Data
  public func parse(data: Foundation.Data) -> Swift.Int
  public func register(delegate: SmartVideo.HTTPHandlerDelegate)
  @objc deinit
}
public enum ConnectionState {
  case connected
  case waiting
  case cancelled
  case failed(Swift.Error?)
  case viability(Swift.Bool)
  case shouldReconnect(Swift.Bool)
  case receive(Foundation.Data)
}
public protocol TransportEventClient : AnyObject {
  func connectionChanged(state: SmartVideo.ConnectionState)
}
public protocol Transport : AnyObject {
  func register(delegate: SmartVideo.TransportEventClient)
  func connect(url: Foundation.URL, timeout: Swift.Double, certificatePinning: SmartVideo.CertificatePinning?)
  func disconnect()
  func write(data: Foundation.Data, completion: @escaping ((Swift.Error?) -> ()))
  var usingTLS: Swift.Bool { get }
}
public struct GenesysEngine : SmartVideo.SmartVideoEngine {
  public var environment: SmartVideo.Environment
  public var commType: SmartVideo.SmartVideoCommunicationChannelType?
  public var isVideo: Swift.Bool
  public var customSettings: [Swift.String : Any]?
  public var displayName: Swift.String
  public var firstName: Swift.String
  public var lastName: Swift.String
  public var memberInfo: [Swift.String : Any]?
  public init(environment: SmartVideo.Environment = .live, commType: SmartVideo.SmartVideoCommunicationChannelType? = .call, isVideo: Swift.Bool = true, customSettings: [Swift.String : Any]? = nil, displayName: Swift.String = "DisplayName", firstName: Swift.String = "Firstname", lastName: Swift.String = "Lastname", memberInfo: [Swift.String : Any]? = nil)
  public func connect()
  public func disconnect()
  public func applicationDidBecomeActive()
  public var pureCloudParams: [Swift.String : Any] {
    get
  }
}
extension Foundation.NSURL {
  public func mimeType() -> Swift.String
}
extension Foundation.URL {
  public func mimeType() -> Swift.String
}
extension Foundation.NSString {
  public func mimeType() -> Swift.String
}
extension Swift.String {
  public func mimeType() -> Swift.String
}
@_hasMissingDesignatedInitializers public class SmartVideoToast {
  public static func show(file: SmartVideo.File, controller: UIKit.UIViewController, acceptAction: @escaping () -> Swift.Void, rejectAction: @escaping () -> Swift.Void)
  @objc deinit
}
public struct GenericEngine : SmartVideo.SmartVideoEngine {
  public var environment: SmartVideo.Environment
  public var shortURL: Swift.String
  public var userAgent: Swift.String
  public init(environment: SmartVideo.Environment = .live, shortURL: Swift.String, userAgent: Swift.String = "")
  public func connect()
  public func disconnect()
  public func applicationDidBecomeActive()
}
@_hasMissingDesignatedInitializers public class FoundationHTTPServerHandler : SmartVideo.HTTPServerHandler {
  public func register(delegate: SmartVideo.HTTPServerDelegate)
  public func createResponse(headers: [Swift.String : Swift.String]) -> Foundation.Data
  public func parse(data: Foundation.Data)
  @objc deinit
}
public struct AgentInfo : Swift.Decodable {
  public var avatarImage: UIKit.UIImage? {
    get
  }
  public var fullname: Swift.String? {
    get
  }
  public init(from decoder: Swift.Decoder) throws
}
public enum ErrorType : Swift.Error {
  case compressionError
  case securityError
  case protocolError
  case serverError
  public static func == (a: SmartVideo.ErrorType, b: SmartVideo.ErrorType) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public struct WSError : Swift.Error {
  public let type: SmartVideo.ErrorType
  public let message: Swift.String
  public let code: Swift.UInt16
  public init(type: SmartVideo.ErrorType, message: Swift.String, code: Swift.UInt16)
}
public protocol WebSocketClient : AnyObject {
  func connect()
  func disconnect(closeCode: Swift.UInt16)
  func write(string: Swift.String, completion: (() -> ())?)
  func write(stringData: Foundation.Data, completion: (() -> ())?)
  func write(data: Foundation.Data, completion: (() -> ())?)
  func write(ping: Foundation.Data, completion: (() -> ())?)
  func write(pong: Foundation.Data, completion: (() -> ())?)
}
extension SmartVideo.WebSocketClient {
  public func write(string: Swift.String)
  public func write(data: Foundation.Data)
  public func write(ping: Foundation.Data)
  public func write(pong: Foundation.Data)
  public func disconnect()
}
public enum WebSocketEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error(Swift.Error?)
  case viabilityChanged(Swift.Bool)
  case reconnectSuggested(Swift.Bool)
  case cancelled
}
public protocol WebSocketDelegate : AnyObject {
  func didReceive(event: SmartVideo.WebSocketEvent, client: SmartVideo.WebSocketClient)
}
open class WebSocket : SmartVideo.WebSocketClient, SmartVideo.EngineDelegate {
  weak public var delegate: SmartVideo.WebSocketDelegate?
  public var onEvent: ((SmartVideo.WebSocketEvent) -> Swift.Void)?
  public var request: Foundation.URLRequest
  public var callbackQueue: Dispatch.DispatchQueue
  public var respondToPingWithPong: Swift.Bool {
    get
    set(newValue)
  }
  public init(request: Foundation.URLRequest, engine: SmartVideo.Engine)
  public convenience init(request: Foundation.URLRequest, certPinner: SmartVideo.CertificatePinning? = FoundationSecurity(), compressionHandler: SmartVideo.CompressionHandler? = nil, useCustomEngine: Swift.Bool = true)
  public func connect()
  public func disconnect(closeCode: Swift.UInt16 = CloseCode.normal.rawValue)
  public func forceDisconnect()
  public func write(data: Foundation.Data, completion: (() -> ())?)
  public func write(string: Swift.String, completion: (() -> ())?)
  public func write(stringData: Foundation.Data, completion: (() -> ())?)
  public func write(ping: Foundation.Data, completion: (() -> ())?)
  public func write(pong: Foundation.Data, completion: (() -> ())?)
  public func didReceive(event: SmartVideo.WebSocketEvent)
  @objc deinit
}
@_hasMissingDesignatedInitializers public class GenesysEngageEngine : SmartVideo.SmartVideoEngine {
  public var environment: SmartVideo.Environment
  public var email: Swift.String
  public var firstName: Swift.String
  public var lastName: Swift.String
  public var nickname: Swift.String
  public var subject: Swift.String
  public var shortURL: Swift.String
  public convenience init(environment: SmartVideo.Environment = .live, shortURL: Swift.String, firstName: Swift.String, lastName: Swift.String, email: Swift.String?, subject: Swift.String?)
  public convenience init(environment: SmartVideo.Environment = .live, shortURL: Swift.String, nickname: Swift.String, email: Swift.String?, subject: Swift.String?)
  public convenience init(environment: SmartVideo.Environment = .live, shortURL: Swift.String, firstName: Swift.String, lastName: Swift.String, nickname: Swift.String, email: Swift.String?, subject: Swift.String?)
  public func connect()
  public func disconnect()
  public func startChat()
  public func applicationDidBecomeActive()
  public var chatParams: [Swift.String : Any] {
    get
  }
  @objc deinit
}
@_hasMissingDesignatedInitializers public class CallManager {
  public func call(hasVideo: Swift.Bool)
  public func startWebRTC()
  public func hangup()
  public func hangupAndEnd()
  public func mute()
  public func unmute()
  public func switchCamera()
  public func torchCamera(on: Swift.Bool)
  public func turnCamera()
  public func stopCamera()
  public func startCamera()
  public func isVideoCall() -> Swift.Bool
  public func turnOffCamera()
  public func turnOnCamera()
  public func turnShareScreen()
  public func turnOffShareScreen()
  public func turnOnShareScreen()
  public func turnOffSpeaker()
  public func turnOnSpeaker()
  public func setupCamera(state: SmartVideo.CameraState?, position: SmartVideo.CameraPosition?)
  public func renderRemoteVideo(renderer: WebRTC.RTCVideoRenderer)
  public func renderRemoteShareScreen(renderer: WebRTC.RTCVideoRenderer)
  public func agentInfo() -> SmartVideo.AgentInfo?
  public func sendFile(url: Foundation.URL, isSecurityScopedResource: Swift.Bool)
  public func sendFile(name: Swift.String, type: Swift.String, data: Foundation.Data)
  @objc deinit
}
public enum CameraPosition {
  case front
  case back
  case shareScreen
  public static func == (a: SmartVideo.CameraPosition, b: SmartVideo.CameraPosition) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum CameraState {
  case on
  case off
  case unknown
  public static func == (a: SmartVideo.CameraState, b: SmartVideo.CameraState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public enum LogLevel : Swift.Int {
  case none
  case error
  case warning
  case info
  case verbose
  public init?(rawValue: Swift.Int)
  public typealias RawValue = Swift.Int
  public var rawValue: Swift.Int {
    get
  }
}
public enum LogType : Swift.String {
  case rest
  case socket
  case rtc
  case webRTC
  case genesys
  case genesysEngage
  case generic
  case callkit
  case sdkInitialization
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public func debug(_ message: Swift.String, level: SmartVideo.LogLevel, type: SmartVideo.LogType, file: Swift.String = #file, method: Swift.String = #function, line: Swift.Int = #line)
@available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
@available(watchOS, unavailable)
public class WebSocketServer : SmartVideo.Server, SmartVideo.ConnectionDelegate {
  public var onEvent: ((SmartVideo.ServerEvent) -> Swift.Void)?
  public init()
  public func start(address: Swift.String, port: Swift.UInt16) -> Swift.Error?
  public func didReceive(event: SmartVideo.ServerEvent)
  @objc deinit
}
@_hasMissingDesignatedInitializers @available(macOS 10.14, iOS 12.0, watchOS 5.0, tvOS 12.0, *)
public class ServerConnection : SmartVideo.Connection, SmartVideo.HTTPServerDelegate, SmartVideo.FramerEventClient, SmartVideo.FrameCollectorDelegate, SmartVideo.TransportEventClient {
  public var onEvent: ((SmartVideo.ConnectionEvent) -> Swift.Void)?
  weak public var delegate: SmartVideo.ConnectionDelegate?
  public func write(data: Foundation.Data, opcode: SmartVideo.FrameOpCode)
  public func connectionChanged(state: SmartVideo.ConnectionState)
  public func didReceive(event: SmartVideo.HTTPEvent)
  public func frameProcessed(event: SmartVideo.FrameEvent)
  public func didForm(event: SmartVideo.FrameCollector.Event)
  public func decompress(data: Foundation.Data, isFinal: Swift.Bool) -> Foundation.Data?
  @objc deinit
}
@_hasMissingDesignatedInitializers public class GenesysAgentData {
  public static var shared: SmartVideo.GenesysAgentData
  public var memberInfo: SmartVideo.GenesysAgentInfo?
  public func clean()
  @objc deinit
}
public protocol EngineDelegate : AnyObject {
  func didReceive(event: SmartVideo.WebSocketEvent)
}
public protocol Engine {
  func register(delegate: SmartVideo.EngineDelegate)
  func start(request: Foundation.URLRequest)
  func stop(closeCode: Swift.UInt16)
  func forceStop()
  func write(data: Foundation.Data, opcode: SmartVideo.FrameOpCode, completion: (() -> ())?)
  func write(string: Swift.String, completion: (() -> ())?)
}
public enum SecurityErrorCode : Swift.UInt16 {
  case acceptFailed
  case pinningFailed
  public init?(rawValue: Swift.UInt16)
  public typealias RawValue = Swift.UInt16
  public var rawValue: Swift.UInt16 {
    get
  }
}
public enum PinningState {
  case success
  case failed(CoreFoundation.CFError?)
}
public protocol CertificatePinning : AnyObject {
  func evaluateTrust(trust: Security.SecTrust, domain: Swift.String?, completion: ((SmartVideo.PinningState) -> ()))
}
public protocol HeaderValidator : AnyObject {
  func validate(headers: [Swift.String : Swift.String], key: Swift.String) -> Swift.Error?
}
extension Swift.KeyedDecodingContainer {
  public func decode<K, V, R>(_ type: [K : V].Type, forKey key: Swift.KeyedDecodingContainer<K>.Key) throws -> [K : V] where K : Swift.Decodable, K : Swift.Hashable, K : Swift.RawRepresentable, V : Swift.Decodable, R : Swift.Decodable, R : Swift.Hashable, R == K.RawValue
}
extension Swift.KeyedEncodingContainer {
  public mutating func encode<K, V, R>(_ value: [K : V], forKey key: Swift.KeyedEncodingContainer<K>.Key) throws where K : Swift.Encodable, K : Swift.Hashable, K : Swift.RawRepresentable, V : Swift.Encodable, R : Swift.Encodable, R : Swift.Hashable, R == K.RawValue
}
@_hasMissingDesignatedInitializers open class RestManager {
  public static var shared: SmartVideo.RestManager
  @objc deinit
}
@_hasMissingDesignatedInitializers open class Networking {
  public static var shared: SmartVideo.Networking
  public func get(urlString: Swift.String, headers: [Swift.String : Swift.String] = defaultHeadersWithUserAgent, completion: @escaping (Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void)
  public func get(url: Foundation.URL, headers: [Swift.String : Swift.String] = defaultHeadersWithUserAgent, completion: @escaping (Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void)
  public func post(url: Swift.String, headers: [Swift.String : Swift.String] = defaultHeadersWithUserAgent, params: [Swift.String : Any], jsonParams: Swift.Bool = true, completion: @escaping (Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void)
  public func delete(url: Swift.String, headers: [Swift.String : Swift.String] = defaultHeadersWithUserAgent, completion: @escaping (Swift.Result<Foundation.Data, Swift.Error>) -> Swift.Void)
  @objc deinit
}
public var defaultHeaders: [Swift.String : Swift.String]
public var defaultHeadersWithUserAgent: [Swift.String : Swift.String]
public var defaultUserAgent: Swift.String
public enum ConnectionEvent {
  case connected([Swift.String : Swift.String])
  case disconnected(Swift.String, Swift.UInt16)
  case text(Swift.String)
  case binary(Foundation.Data)
  case pong(Foundation.Data?)
  case ping(Foundation.Data?)
  case error(Swift.Error)
}
public protocol Connection {
  func write(data: Foundation.Data, opcode: SmartVideo.FrameOpCode)
}
public protocol ConnectionDelegate : AnyObject {
  func didReceive(event: SmartVideo.ServerEvent)
}
public enum ServerEvent {
  case connected(SmartVideo.Connection, [Swift.String : Swift.String])
  case disconnected(SmartVideo.Connection, Swift.String, Swift.UInt16)
  case text(SmartVideo.Connection, Swift.String)
  case binary(SmartVideo.Connection, Foundation.Data)
  case pong(SmartVideo.Connection, Foundation.Data?)
  case ping(SmartVideo.Connection, Foundation.Data?)
}
public protocol Server {
  func start(address: Swift.String, port: Swift.UInt16) -> Swift.Error?
}
